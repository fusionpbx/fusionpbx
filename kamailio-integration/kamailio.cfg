#!KAMAILIO
# Kamailio SIP edge for FusionPBX

#!substdef "!MY_IP_ADDR!5.161.71.60!g"
#!substdef "!FREESWITCH_IP!127.0.0.1!g"
#!substdef "!FREESWITCH_PORT!5090!g"
#!substdef "!PUSH_URL!https://api.davincitechsolutions.com/api/kamailio/send-push!g"
#!substdef "!PUSH_API_KEY!TUsVwYzssl6Z5EvrVcAszaMJQmaGOmp70R56HbQn!g"
#!substdef "!FUSIONPBX_DB_URL!postgres://kamailio_ro:yPJa8irFAPQkb4za60CCTcMA@localhost/fusionpbx!g"
#!substdef "!KAMAILIO_DB_URL!postgres://kamailio:6mmvfq93Sgaes4epRJFVbIGp@localhost/kamailio!g"

debug=2
log_stderror=no
log_facility=LOG_LOCAL0
children=4
tcp_children=4
tcp_connection_lifetime=3605
tcp_accept_no_cl=yes
tcp_rd_buf_size=16384
auto_aliases=no
enable_tls=yes

listen=udp:MY_IP_ADDR:5060
listen=tcp:MY_IP_ADDR:5060
listen=tls:MY_IP_ADDR:5061
listen=tls:MY_IP_ADDR:443

port=5060

loadmodule "db_postgres.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "auth.so"
loadmodule "auth_db.so"
loadmodule "nathelper.so"
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "tls.so"
loadmodule "websocket.so"
loadmodule "xhttp.so"
loadmodule "http_client.so"
loadmodule "tsilo.so"
loadmodule "sqlops.so"
loadmodule "rtpengine.so"

modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)
modparam("tm", "restart_fr_on_each_reply", 1)

modparam("rr", "enable_full_lr", 0)
modparam("rr", "append_fromtag", 0)

modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "min_expires", 60)
modparam("registrar", "default_expires", 300)
modparam("registrar", "use_path", 1)
# Filter out contacts with dead TCP/WS connections during lookup
modparam("registrar", "lookup_filter_mode", 2)

modparam("usrloc", "db_url", "KAMAILIO_DB_URL")
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", 1)
modparam("usrloc", "handle_lost_tcp", 1)

modparam("auth_db", "db_url", "FUSIONPBX_DB_URL")
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", 1)
modparam("auth_db", "version_table", 0)
modparam("auth_db", "user_column", "username")
modparam("auth_db", "domain_column", "domain")

modparam("tls", "config", "/etc/kamailio/tls.cfg")
modparam("tls", "tls_force_run", 1)

modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "sub_protocols", 1)

modparam("nathelper", "received_avp", "$avp(RECEIVED)")
modparam("nathelper", "natping_interval", 30)

modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 4)

modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")

modparam("tsilo", "hash_size", 2048)
modparam("tsilo", "use_domain", 1)

modparam("http_client", "connection_timeout", 5)

modparam("sqlops", "sqlcon", "fpbx=>FUSIONPBX_DB_URL")

modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:2223")

request_route {
    route(REQINIT);

    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    if (!is_method("ACK")) {
        if (t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    route(WITHINDLG);

    if (!is_method("REGISTER")) {
        if (is_method("INVITE|SUBSCRIBE")) {
            record_route();
        }
    }

    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    if ($rU == $null) {
        sl_send_reply("484", "Address Incomplete");
        exit;
    }

    route(AUTH);
    route(LOCATION);
}

route[RELAY] {
    if (is_request()) {
        t_on_branch("MANAGE_BRANCH");
        t_on_reply("MANAGE_REPLY");
    }

    # WebSocket contacts often use RFC 7118 .invalid host + alias parameter.
    # Rewrite Request-URI to alias destination before t_relay().
    if (is_request() && $ru =~ ";alias=") {
        handle_ruri_alias();
        if (is_method("ACK")) {
            xlog("L_INFO", "RELAY ACK after handle_ruri_alias: du=$du ru=$ru\n");
        }
    }

    # Fallback for ACK to WebSocket client: if handle_ruri_alias could not
    # resolve the destination, do a fresh usrloc lookup to get the correct
    # WS TCP connection ID.
    if (is_method("ACK")) {
        if ($du == $null || $du =~ "5.161.71.60") {
            xlog("L_WARN", "ACK with unresolved du=$du ru=$ru - usrloc lookup for $tU@$td\n");
            if (lookup("location", "sip:$tU@$td")) {
                if ($ru =~ ";alias=") {
                    handle_ruri_alias();
                }
                xlog("L_INFO", "ACK usrloc fallback: du=$du ru=$ru\n");
            } else {
                xlog("L_ERR", "ACK usrloc fallback failed for $tU@$td\n");
            }
        }
    }

    if (is_method("ACK|BYE|INVITE")) {
        xlog("L_INFO", "RELAY $rm: du=$du ru=$ru method=$rm\n");
    }

    if (!t_relay()) {
        xlog("L_ERR", "t_relay failed for $rm du=$du ru=$ru\n");
        sl_reply_error();
    }
    exit;
}

branch_route[MANAGE_BRANCH] {
    if ($ru =~ ";alias=") {
        handle_ruri_alias();
    }
}

# Process replies to add Contact alias for WebSocket clients.
# Without this, 200 OK from WS clients has no alias in the Contact,
# so the caller's ACK Request-URI has no alias and handle_ruri_alias()
# cannot resolve the WS destination → protocol/port mismatch.
onreply_route[MANAGE_REPLY] {
    # Log replies coming back from FreeSWITCH (helps debug silent calls)
    if ($si == "127.0.0.1") {
        xlog("L_INFO", "REPLY from FreeSWITCH: $rs $rr (to $ru)\n");
    }

    # rtpengine: handle SDP in replies with DIRECTIONAL conversion
    if (has_body("application/sdp")) {
        if ($si == "127.0.0.1" || $si == "5.161.71.60") {
            # Reply FROM FreeSWITCH → going to WebRTC client
            # Convert FS plain RTP answer to WebRTC (DTLS/ICE)
            rtpengine_answer("replace-origin replace-session-connection ICE=force DTLS=on rtcp-mux-offer rtcp-mux-require UDP/TLS/RTP/SAVPF");
            xlog("L_INFO", "RTPENGINE: answer FS→WebRTC rs=$rs\n");
        } else {
            # Reply FROM mobile WebRTC client → going to FreeSWITCH
            # Convert WebRTC answer back to plain RTP
            rtpengine_answer("replace-origin replace-session-connection ICE=remove RTP/AVP");
            xlog("L_INFO", "RTPENGINE: answer WebRTC→RTP rs=$rs from $si:$sp\n");
        }
    }

    # For NATed clients (esp WS), add contact alias on replies
    if (nat_uac_test("19")) {
        set_contact_alias();
    }
}

route[REQINIT] {
    if ($sht(ipban=>$si) != $null) {
        xlog("L_WARN", "Blocked IP $si\n");
        exit;
    }

    if (!pike_check_req()) {
        xlog("L_ALERT", "PIKE blocking $rm from $si:$sp\n");
        $sht(ipban=>$si) = 1;
        exit;
    }

    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    if (is_method("OPTIONS") && uri == myself && $rU == $null) {
        sl_send_reply("200", "Keepalive");
        exit;
    }

    if (!sanity_check("17895", "7")) {
        xlog("L_WARN", "Malformed SIP message from $si:$sp\n");
        exit;
    }

    force_rport();
}

route[WITHINDLG] {
    if (!has_totag()) return;

    if (loose_route()) {
        if (is_method("ACK")) {
            xlog("L_INFO", "In-dialog ACK after loose_route: du=$du ru=$ru tU=$tU td=$td\n");
            route(NATMANAGE);
        }
        route(RELAY);
        exit;
    }

    if (is_method("ACK")) {
        if (t_check_trans()) {
            xlog("L_INFO", "ACK matched transaction: du=$du ru=$ru\n");
            route(RELAY);
            exit;
        }
        exit;
    }

    sl_send_reply("404", "Not here");
    exit;
}

route[REGISTRAR] {
    if (!auth_check("$fd", "kamailio_subscribers", "1")) {
        auth_challenge("$fd", "1");
        exit;
    }
    consume_credentials();

    if (nat_uac_test("19")) {
        set_contact_alias();
    }

    # Single-contact policy for WebSocket: new WS REGISTER replaces previous one.
    # Prevents forking across dead WS branches and protocol/port mismatch.
    # $Rp==443 = WSS listener; $proto can be ws/wss depending on Kamailio version
    if ($Rp == 443 || $proto == "ws" || $proto == "wss") {
        if (!save("location", "0x04")) {
            sl_reply_error();
            exit;
        }
    } else {
        if (!save("location")) {
            sl_reply_error();
            exit;
        }
    }

    $var(tsret) = ts_append("location", "$tu");
    if ($var(tsret) == 1) {
        xlog("L_INFO", "Released queued INVITE for $tu\n");
    }

    exit;
}

route[AUTH] {
    if ($si == "FREESWITCH_IP" || $si == "127.0.0.1" || $si == "MY_IP_ADDR") {
        return;
    }

    # Trust Twilio SIP trunk IPs (no auth required)
    if ($si =~ "^54\.172\.60\." || $si =~ "^54\.244\.51\." || $si =~ "^34\.203\.250\." || $si =~ "^54\.171\.127\.") {
        xlog("L_INFO", "Trusted Twilio source: $si:$sp\n");
        return;
    }

    if (is_method("INVITE|MESSAGE|SUBSCRIBE|NOTIFY|REFER|INFO")) {
        if (!auth_check("$fd", "kamailio_subscribers", "1")) {
            auth_challenge("$fd", "1");
            exit;
        }
        consume_credentials();
    }
}

route[LOCATION] {
    if (is_method("INVITE")) {
        # Calls coming FROM FreeSWITCH: deliver directly to registered endpoint
        if ($si == "127.0.0.1" || $si == "FREESWITCH_IP" || $si == "MY_IP_ADDR") {
            xlog("L_INFO", "B-leg INVITE from FreeSWITCH: $fU -> $rU (src=$si:$sp)\n");
            if (lookup("location")) {
                # Convert plain RTP from FS to WebRTC for mobile clients
                if (has_body("application/sdp")) {
                    rtpengine_offer("replace-origin replace-session-connection ICE=force generate-mid DTLS=on SDES-off rtcp-mux-offer rtcp-mux-require UDP/TLS/RTP/SAVPF");
                    xlog("L_INFO", "RTPENGINE B-leg offer for $rU - body: $(rb{s.substr,0,300})\n");
                }
                route(NATMANAGE);
                t_on_failure("MANAGE_FAILURE");
                route(RELAY);
                exit;
            }

            if ($retcode == -1 || $retcode == -3) {
                route(CHECK_AND_PUSH);
                exit;
            }

            if ($retcode == -2) {
                sl_send_reply("405", "Method Not Allowed");
                exit;
            }
        }

        # ALL client calls go through FreeSWITCH for media anchoring
        # FS is the B2BUA - it bridges RTP between endpoints
        # This handles: ext-to-ext, outbound PSTN, IVR, ring groups, voicemail
        xlog("L_INFO", "CLIENT INVITE: $fU -> $rU sending to FreeSWITCH for media anchoring\n");
        route(TOFREESWITCH);
        exit;
    }

    route(TOFREESWITCH);
    exit;
}

route[CHECK_AND_PUSH] {
    if (!is_method("INVITE")) {
        route(TOFREESWITCH);
        exit;
    }

    $var(ext) = $(rU{s.escape.common});
    $var(rdomain) = $(rd{s.escape.common});
    $var(tdomain) = $(td{s.escape.common});
    $var(fdomain) = $(fd{s.escape.common});

    sql_query("fpbx", "SELECT e.extension_uuid::text, e.extension, d.domain_uuid::text, d.domain_name FROM v_extensions e JOIN v_domains d ON e.domain_uuid = d.domain_uuid WHERE e.extension = '$var(ext)' AND e.enabled = 'true' AND d.domain_enabled = true AND d.domain_name IN ('$var(rdomain)', '$var(tdomain)', '$var(fdomain)') LIMIT 1", "ra");

    if ($dbr(ra=>rows) == 0) {
        sql_query("fpbx", "SELECT e.extension_uuid::text, e.extension, d.domain_uuid::text, d.domain_name FROM v_extensions e JOIN v_domains d ON e.domain_uuid = d.domain_uuid WHERE e.extension = '$var(ext)' AND e.enabled = 'true' AND d.domain_enabled = true LIMIT 1", "ra");
    }

    if ($dbr(ra=>rows) == 0) {
        route(TOFREESWITCH);
        exit;
    }

    $var(extension_uuid) = $dbr(ra=>[0,0]);
    $var(extension) = $dbr(ra=>[0,1]);
    $var(domain_uuid) = $dbr(ra=>[0,2]);
    $var(domain) = $dbr(ra=>[0,3]);

    xlog("L_INFO", "Unregistered extension $var(extension)@$var(domain) - trigger push\n");
    route(SEND_PUSH);

    if (!t_newtran()) {
        sl_reply_error();
        exit;
    }

    t_on_failure("TSILO_FAILURE");
    t_set_fr(60000, 60000);

    if (ts_store("$ru") < 0) {
        xlog("L_ERR", "TSILO store failed for $ru\n");
    }

    t_reply("100", "Trying");
    exit;
}

route[SEND_PUSH] {
    $var(push_body) = "{\"call_id\":\"$ci\",\"call_uuid\":\"$ci\",\"from_uri\":\"$fu\",\"to_extension\":\"$var(extension)\",\"extension_number\":\"$var(extension)\",\"domain\":\"$var(domain)\",\"caller_number\":\"$fU\",\"caller_name\":\"$fn\",\"domain_uuid\":\"$var(domain_uuid)\",\"wake_only\":true}";
    $var(push_hdrs) = "Content-Type: application/json\r\nX-Kamailio-Api-Key: PUSH_API_KEY\r\n";

    $var(http_rc) = http_client_query("PUSH_URL", "$var(push_body)", "$var(push_hdrs)", "$var(push_result)");

    if ($var(http_rc) < 0) {
        xlog("L_ERR", "Push HTTP request failed for $var(extension)@$var(domain): rc=$var(http_rc)\n");
        return;
    }

    if ($var(http_rc) >= 200 && $var(http_rc) < 300) {
        xlog("L_INFO", "Push sent for $var(extension)@$var(domain) rc=$var(http_rc)\n");
    } else {
        xlog("L_ERR", "Push failed for $var(extension)@$var(domain) rc=$var(http_rc) body=$var(push_result)\n");
    }
}

route[TOFREESWITCH] {
    $du = "sip:FREESWITCH_IP:FREESWITCH_PORT";

    # Convert WebRTC SDP to plain RTP for FreeSWITCH
    if (has_body("application/sdp")) {
        rtpengine_offer("replace-origin replace-session-connection ICE=remove RTP/AVP");
        xlog("L_INFO", "RTPENGINE: WebRTC→RTP for $fU -> $rU\n");
    }

    route(NATMANAGE);
    route(RELAY);
}

route[NATMANAGE] {
    if (nat_uac_test("19")) {
        if (is_request() && !is_method("REGISTER") && is_first_hop()) {
            set_contact_alias();
        }
        if (is_reply() && is_first_hop()) {
            set_contact_alias();
        }
    }
}

failure_route[MANAGE_FAILURE] {
    if (t_is_canceled()) exit;

    if (t_check_status("408|480|486|487")) {
        xlog("L_INFO", "Call failure $T_reply_code for $rU - forwarding to FreeSWITCH\n");
        $du = "sip:FREESWITCH_IP:FREESWITCH_PORT";
        $ru = "sip:$rU@FREESWITCH_IP:FREESWITCH_PORT";
        append_hf("X-Call-Failure: $T_reply_code\r\n");
        t_on_failure("FS_FAILURE");
        if (!t_relay()) {
            xlog("L_ERR", "Relay to FreeSWITCH failed after MANAGE_FAILURE\n");
        }
        exit;
    }
}

failure_route[TSILO_FAILURE] {
    if (t_is_canceled()) exit;

    if (t_check_status("408|480|500|503")) {
        xlog("L_INFO", "TSILO timeout/failure for $rU - forwarding to FreeSWITCH\n");
        $du = "sip:FREESWITCH_IP:FREESWITCH_PORT";
        $ru = "sip:$rU@FREESWITCH_IP:FREESWITCH_PORT";
        append_hf("X-Push-Timeout: true\r\n");
        t_on_failure("FS_FAILURE");
        if (!t_relay()) {
            xlog("L_ERR", "Relay to FreeSWITCH failed after TSILO failure\n");
        }
        exit;
    }
}

failure_route[FS_FAILURE] {
    if (t_is_canceled()) exit;
    xlog("L_ERR", "FreeSWITCH returned failure $T_reply_code for $rU\n");
}

event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();

    if ($Rp != 443) {
        xlog("L_WARN", "HTTP request received on unexpected port $Rp\n");
        xhttp_reply("403", "Forbidden", "", "");
        exit;
    }

    if ($hu != "/ws") {
        xhttp_reply("404", "Not Found", "", "");
        exit;
    }

    if ($rm == "GET" && $hdr(Upgrade) =~ "websocket") {
        if (ws_handle_handshake()) {
            xlog("L_INFO", "WebSocket handshake accepted from $si:$sp\n");
            exit;
        }
    }

    xhttp_reply("404", "Not Found", "", "");
    exit;
}

event_route[websocket:closed] {
    xlog("L_INFO", "WebSocket closed from $si:$sp\n");
}

